# 1、浏览器工作原理

### 1、浏览器总论

* #### 浏览器工作原理总论

  我们看到的页面都是一个图片形式，专业点的说法叫做位图（Bitmap），然后经过显卡转换为我们可以识别的光信号。

  整个的过程就是从 URL 转换为 Bitmap 的过程，先发送请求到服务器，然后服务器返回 HTML，浏览器解析 HTML（词法和语法解析），然后构建 DOM 树，解析CSS 属性（解析成rule，然后对应到Dom树）得到带有css属性的Dom树，然后进行排版，最后渲染成位图，然后经过操作系统或硬件的 API 完成视图的显示

  ![截屏2021-04-12 下午8.25.25](/Users/curtis/Documents/极客时间/前端进阶训练营/img/截屏2021-04-12 下午8.25.25.png)

* #### 浏览器的渲染流水线

  ![截屏2021-04-20 下午8.46.45](/Users/curtis/Documents/极客时间/前端进阶训练营/img/截屏2021-04-20 下午8.46.45.png)

### 2、状态机 ｜ 有限状态机

* #### 每一个状态都是一个机器

  * 在每个机器中做计算、存储、输出
  * 接受输入一致
  * 本身没有状态，纯函数

* #### 分类

  * (Moore) 每个机器有确定的下一个状态，不会因为输入不同去切换不同分支
  * (Mealy) 每个机器根据输入确定下一个状态

* #### JS中状态机实现方式

  一系列返回状态函数的一种状态函数

  ![截屏2021-04-20 下午8.52.40](/Users/curtis/Documents/极客时间/前端进阶训练营/img/截屏2021-04-20 下午8.52.40.png)

### 3、HTTP请求 ｜ HTTP的协议解析

##### 3.1、ISO- OSI七层网络模型

![截屏2021-04-18 下午3.42.57](/Users/curtis/Documents/极客时间/前端进阶训练营/img/截屏2021-04-18 下午3.42.57.png)

##### 3.2 、TCP/IP基础知识

1、计算机网卡根据端口把接收到的数据包分给各个应用，对应到node里就要使用require('net')包来完成；

2、IP包使用IP地址来寻找传输的目的地；

​	IP协议的底层库在Node中没有，但是node底层是调用C++ 的libnet/libpcap这两个库；libnet负责构造IP包并且发送；libpcap负责抓取流经你网卡的IP包



##### 3.3、HTTP

HTTP协议是一个文本型的协议（与二进制协议相对），里面所有的内容都是字符串，每一个字节都会被理解成字符串的一部分

* Request

  ![截屏2021-04-18 下午4.33.41](/Users/curtis/Documents/极客时间/前端进阶训练营/img/截屏2021-04-18 下午4.33.41.png)

  * 第一行：request line
    * Method
    * Path
    * HTTP
    * HTTP version
  * 第二行：headers (key:value键值对形式)，以一个空白行为标志进行结束的
  * 第三行：body
    * 由content-type来决定格式
  * http中所有的换行都是由\r\n组成的

* Response

![截屏2021-04-18 下午7.26.24](/Users/curtis/Documents/极客时间/前端进阶训练营/img/截屏2021-04-18 下午7.26.24.png)

* 第一行：status line
  * HTTP/HTTP Version
  * 状态码 200    响应状态码都有哪些？代表什么意思？
  * 状态文本
* 第二行：headers 尾部空行分隔
* 第三行：
  * 典型的body格式：chunked body
  * 头尾是由两个16进制数字构成
  * body不会被任何分隔符分割

###### HTTP 代码编写总结

* 第一步 HTTP请求总结

  * 设计一个HTTP请求的类
  * Content-Type 是必要字段，要有默认值
  * Content-Length是必要字段，一般在代码内部定义好
  * body是KV格式
  * 不同的Content-Type影响body的格式

* 第二步 Send函数总结

  * 在Request的构造器里收集必要的信息
  * 设计一个send函数，把请求真实发送到服务器
  * send函数是异步的，所以返回是一个Promise

* 第三步 发送请求

  * 设计支持已有的connection或者自己新建connection

  * 请求返回的数据传给parser

  * 根据parser（使用状态机原理实现）的状态resolve Promise

  * 坑点

    * 在toString的代码中运行会报错bad request 

      ```js
      toString () {
      	return `${this.method} ${this.path} HTTP/1.1\r${Object.keys(this.headers)
      .map((key) => `${key}: ${this.headers[key]}`)
      .join("\r\n")}\r\r${this.bodyText}`; 
      }
      ```

      原因是HTTP协议规定，只写\r是不可以的，必须要写 \r\n

    * Server.js的代码中

      ```js
      body = Buffer.concat(body).toString(); //报错The "list[0]" argument must be an instance of Buffer or Uint8Array. Received
      //原因是 Buffer.concat()的入参类型是list:uint8Array 而body里面是string
      
      //解决方法：使用Buffer.from()
      body = Buffer.concat([Buffer.from(body.toString())]).toString();
      ```

* 第四步 ResponseParser总结

  * Response 必须分段构造，所以使用一个ResponseParser装配
  * ResponseParser分段处理ResponseText，我们用状态机来处理文本的结构

* 第五步 BodyParser总结

  * Response的body可能根据Content-Type有不同的结构，因此采用子parser的结构来解决问题
  * 以TrunkedBodyParser为例，我们同样用状态机来处理body的格式
  * BodyParser的创建与header有关，不能在一开始就直接创建；在Header全部接收以后再创建BodyParser

  

### 4、HTML解析 

* 从Response Body中获得的HTML源代码经过状态机的词法分析得到 标签和文本

* 标签和文本经过在栈里语法分析得到DOM树（带Element和TextNode）

### ![截屏2021-04-27 上午8.23.41](/Users/curtis/Documents/极客时间/前端进阶训练营/img/截屏2021-04-27 上午8.23.41.png)



### 5、CSS computing

#####  5.1 CSS selector

##### ![截屏2021-04-27 上午8.33.54](/Users/curtis/Documents/极客时间/前端进阶训练营/img/截屏2021-04-27 上午8.33.54.png)

* 复合选择器？

##### 5.2 CSS Selector Specificity

CSS选择器优先级通过这种四元数组的方式进行计算比较

<img src="/Users/curtis/Documents/极客时间/前端进阶训练营/img/截屏2021-04-27 上午8.38.02.png" alt="截屏2021-04-27 上午8.38.02" style="zoom:50%;" />

##### 5.3 CSS 计算

<img src="/Users/curtis/Documents/极客时间/前端进阶训练营/img/截屏2021-04-27 上午8.42.43.png" alt="截屏2021-04-27 上午8.42.43" style="zoom:67%;" />

### 6、CSS 布局(layout)

#####  6.1 css布局的历史

* 第一代： 正常流
* 第二代：flex
* 第三代：grid
* 第四代：Houdini（可能）

##### 6.2 flex-wrap属性

* Flex-wrap: nowrap
* flex-wrap: wrap
  * <img src="/Users/curtis/Documents/极客时间/前端进阶训练营/img/截屏2021-04-29 下午9.47.31.png" alt="截屏2021-04-29 下午9.47.31" style="zoom: 67%;" />
  * 
* flex-wrap: wrap-reverse
  * ​	**<img src="/Users/curtis/Documents/极客时间/前端进阶训练营/img/截屏2021-04-29 下午9.48.33.png" alt="截屏2021-04-29 下午9.48.33" style="zoom:67%;" />**
  * 该属性与主轴无关，主要与交叉轴有关系

##### 6.4 Void 0 与 undefined的区别

* undefined可以被重写
  * undefined在ES5是全局对象的一个只读属性，但是在局部作用域中是可以被重写的
  * 为什么用void 0来代替 undefined ?
    * void运算符可以对给定表达式进行求值，然后返回undefined  如：void(2)、void(hello)等，但是为什么用void(0)因为是表达式中最短的，节省字节、
    * 不少JS压缩工具都是在压缩过程中将undefined用void(0)来替代

##### 代码编写步骤解析

* 第一步
  * 为了方便管理，把parser单独抽离到一个文件中
  * parser接受HTML文本作为参数，返回一颗DOM树
* 第二步
  * HTML的词法使用的就是状态机的方式
  * 用FSM（有限状态机）来实现HTML的分析
  * HTML标准里已经规定了HTML的状态
* 第三步 解析标签
  * HTML tag主要分为三类：开始标签、结束标签、自封闭标签
  * HTML中有效的空白符有四种：tab符（\t）、换行符（\n）、禁止符（\f）、和空格
* 第四步 创建元素
  * 在状态机中，除了状态迁移，我们还要会加入业务逻辑（创建token, 把字符加到token，然后emit token）
  * 我们在标签结束状态提交标签token
* 第五步 处理属性
  * 属性值分为单引号、双引号、无引号三种
  * 处理属性方式和标签类似，都是先暂存，最后添加属性
  * 属性结束时，把属性加到标签的Token上
* 第六步 用token构建Dom树
  * 从标签构建DOM树的基本技巧是使用栈
  * 遇到开始标签的时候创建元素并且入栈，遇到结束标签的时候出栈
  * 自封闭标签可以视为入栈以后立即出栈
  * 任何元素的父元素都是他入栈前的栈顶元素，把当前元素插入到父元素的子元素上
* 第七步 将文本节点加到DOM树
  * 文本节点与自封闭标签处理类似
  * 多个文本节点需要合并
* 第八步 收集CSS规则
  * AST抽象语法树???
  * 遇到Style标签时，把CSS规则保存起来
  * 调用CSS parser来分析CSS规则
  * 仔细研究此库分析CSS规则的格式
  * 当创建一个元素后，立即计算CSS
  * 真实浏览器环境中，可能遇到写在body的style标签，此时需要重新CSS计算，在本次开发中可以忽略。
  * 获取父元素序列
    * 在compute CSS函数中，我们必须要知道所有的父元素才能判断元素与规则是否匹配
    * 我们从上一步骤的stack，可以获取本元素的所有父元素
    * 因为我们首先获取的是“当前元素”，所以我们获得和计算父元素匹配顺序是从内向外
  * 选择器与元素的匹配
    * 选择器与当前元素的父元素排列顺序是一致的，从内向外匹配
    * 复杂选择器拆成针对单个元素的选择器，通过循环匹配父元素列表
  * 计算选择器与元素匹配
    * 根据选择器的类型和元素属性，计算是否与当前元素匹配
    * 案例仅仅实现了三种基本选择器（id clss 标签）实际浏览器中要处理复合选择器
  * 生成computed属性
    * 一旦选择匹配，就行用选择器到元素上，行程computedStyle
  * Specificity 的计算逻辑
    * CSS规则根据Specificity和后来优先的规则覆盖
    * Specificity是个四元组，越左权限越高
    * 一个CSS规则的specificity根据包含的简单选择器相加而成
* 第九步 排版（layout）
  * 根据浏览器属性进行排版
    * 处理flex-direction 和 warp相关的属性，将具体的width、height、top、bottom、left、right等属性抽象为main cross等
  * 收集元素进行
    * 分行
      * 根据主轴尺寸，将元素分行
      * 如果设置了no-wrap 则强行分配进第一行
    * 计算主轴
      * 找出所有的flex元素
      * 把主轴剩余的空间按照比例分配给这些flex元素
      * 若剩余空间为负数，则flex元素为0，等比压缩剩余元素
      * 如果没有flex元素，则根据justify-content来计算所有元素的位置
    * 计算交叉轴（非主轴方向）
      * 根据每一行中最大元素尺寸计算行高
      * 根据行高flex-align和item-align计算元素的具体位置
  * 绘制单个元素
    * 绘制需要依赖一个图形环境
    * 我们在这里使用npm包images
    * 绘制在viewport上进行
    * 与绘制相关属性：background- color、border、background- image等
  * 绘制DOM树
    * 递归调用子元素的绘制方法完成DOM树的绘制
    * 忽略一些不需要绘制的节点
    * 实际浏览器中，文字绘制是难点，需要依赖字体库，本次开发忽略
    * 实际浏览器中，会对一些图层做compositing，这里也忽略